C **********************************************************************
C *                                                                    *
C * STRING                                                             *
C *                                                                    *
C * USES A TECHNIQUE DESCRIBED BY DAVID R HANSON, 'A SIMPLE TECHNIQUE  *
C * FOR REPRESENTING STRINGS IN FORTRAN IV', COMMUNICATIONS OF THE     *
C * ACM, NOVEMBER 1974                                                 *
C *                                                                    *
C **********************************************************************
C
C NOTES
C
C  1 WE DON'T COMPACT STRING STORAGE, BUT WE USE THE UPPER PART FOR
C    TEMPORARY STRINGS. TEMP$(N) RETURNS A SUCH A TEMPORARY, NEW$(N)
C    RETURNS A PERMANENT STRING FROM THE BOTTOM. THE STRING STORAGE IS
C    DEFINED IN COMMON STRSTO.
C
C  2 IF WE DON'T DO GARBAGE COLLECTION, WE CAN SHARE PARTS OF STRINGS.
C    THIS MEANS THAT LEFT, RIGHT, MID DO NOT HAVE TO COPY DATA, AND ARE
C    THEN TRIVIAL AND VERY FAST. MARK AND RELEASE WORK LIKE A STACK.
C
C  3 SETTING STRUSE TO 1 (CALL STRCLR) WILL CLEAR ALL PERMANENT STRING
C    STORAGE. SETTING STRMAX TO THE UPPER LIMIT OF STRDAT WILL CLEAR ALL
C    TEMPORARY STRING STORAGE. JUST BE CAREFUL ABOUT DANGLING STRINGS
C    THAT STILL REFERENCE THE STRDAT AREA. M = MARK(0) AT THE START WILL
C    CAPTURE STRMAX. RELEAS(M) WILL THEN CLEAR ALL TEMPORARY STORAGE.
C
C  4 FOR L80, THE LARGEST COMMON DEFINITION MUST BE FIRST -- THIS IS IN
C    STRSTO. (PLINK-II CAN HELP ALLEVIATE THIS)
C
C  5 CHARAT (RETURN CHARACTER AT) RETURNS INTEGER: 0..255. BYTE IS
C    -128..128, IF IT IS ASKED TO RETURN A CHARACTER NOT IN THE STRING
C    (OUT OF RANGE) IT RETURNS NOCHAR. NOCHAR IS DEFINED TO BE 257,
C    WHICH IS OUT OF EITHER -128..127 OR 0...255.
C    IN FUTURE, EOF MAY BE DEFINED AS -1, NOCHAR IS NOT EOF, NOT A
C    CHARACTER.
C
C  6 WITH MICROSOFT F80, IT IS NOT POSSIBLE TO USE PARAMETERS DIRECTLY
C    IN THE EQUIVALENCE STATEMENT. F80 DOES NOT BELIEVE THAT A
C    PARAMETER IS A VARIABLE. SO, WE COPY TO VARIABLES AS NEEDED.
C    OTHER COMPILERS MAY HAVE THE SAME BEHAVIOUR.
C
C  7 A STRING IS TWO INTEGERS PACKED INTO A REAL. THIS WORKS FOR F80
C    AND IBM 1130 FORTRAN. TWO INTEGERS MAY BE PACKED INTO EITHER A
C    COMPLEX OR A DOUBLE PRECISION ON OTHER MACHINES (AS DESCRIBED BY
C    HANSON). NEITHER F80 NOR IBM 1130 IMPLEMENT COMPLEX. WITH IBM 1130
C    FORTRAN, USE *ONE WORD INTEGER.
C
C  8 UNDERLYING STRING STORAGE IS DECLARED BYTE WITH F80. OTHER SYSTEMS
C    MAY NEED INTEGER*1 OR OTHER CODE. THIS WOULD BE RELATED TO HOW
C    HOLLERITH IS PASSED AS A PARAMETER. IT IS POSSIBLE TO USE INTEGER
C    AS THE UNDERLYING STORAGE. NOTE THAT THIS AFFECTS STRDAT INDEXING
C    BUT THE EFFECTS ARE ISOLATED TO THIS MODULE. LENGTH IS STILL IN
C    CHARACTERS (BYTES).
C
C  9 EDIT 4096 IN STRSTO TO THE NUMBER OF BYTES OF STRING STORAGE
C    NEEDED.
C
C 10 WE DO NOT HAVE A 'PUTAT' SUBROUTINE THAT IS LIKE CHARAT()
C    FUNCTION WE MAY WANT TO VIEW STRINGS AS IMMUTABLE. NOTE THAT
C    STRCAT SHOULD PROBABLY RETURN A NEW STRING, INSTEAD OF MODIFING
C    THE DST$ STRING. NOTE THAT STRCAT WILL NOT INVALIDATE LEFT$, MID$
C    OR RIGHT$ RESULT STRINGS. DO NOT STRCAT TO ANYTHING BUT A NEW$
C    OR TEMP$ STRING THAT IS LONG ENOUGH (SAME WITH STRCPY).
C
      PROGRAM STRING
C
      REAL S$, T$, U$, V$
      INTEGER I, J, M
      BYTE B
      BYTE IXX(4)
C
C STRCON CAN BE USED BY CALLING FUNCTIONS. STRSTO SHOULD BE
C PRIVATE TO STRLIB FUNCTIONS.
C
      INCLUDE STRING.INC
C
      DATA IXX /'E', 'F', 'G', 'H'/
C
      WRITE (1, 405)
  405 FORMAT (1X, 'STRING - TEST STRINGS')
C
      CALL STRCLR
      I = AVAIL(0)
      WRITE (1, 502) I
  502 FORMAT (1X, 'AVAIL = ', I6)
C
C CREATE A NEW STRING, MAXIMUM OF 80 CHARACTERS. SET STRING TO
C 'HELLO, WORLD', WHICH IS 12 CHARACTERS IN LENGTH.
C 
      S$ = NEW$(80)
      CALL STRPUT(S$, 'HELLO, WORLD', 12)
C
      T$ = NEW$(1024)
C
C DISPLAY OFFSET AND LENGTH OF S$
C
      I = STROFF(S$)
      J = STRLEN(S$)
      WRITE (1, 300) I, J
  300 FORMAT(1X, 'I ', I6, ' J ', I6)
C
C SAME FOR T$
C
      I = STROFF(T$)
      J = STRLEN(T$)
      WRITE (1, 300) I, J
C
C STRCPY TEST
C
      CALL STRCPY(T$, S$)
      CALL STRPRI(1, S$)
      CALL STRPRI(1, T$)
C
C LEFT/MID TEST
C
      V$ = LEFT$(S$, 5)
      CALL STRPRI(1, V$)
      V$ = MID$(S$, 5, 2)
      CALL STRPRI(1, V$)
C
C MARK/RELEAS TEST
C
      M = MARK(0)
      WRITE (1, 301) M
  301 FORMAT (1X, 'M ', I6)
      U$ = TEMP$(20)
      I = STROFF(U$)
      J = STRLEN(U$)
      WRITE (1, 300) I, J
      CALL RELEAS(M)
C
      V$ = RIGHT$(S$, 2)
      J = STRLEN(V$)
      CALL STRPRI(1, V$)
      WRITE (1, 302) J
  302 FORMAT (1X, 'LEN ', I6)
C
C STRING CONCATENATE TEST
C
      CALL STRPUT(S$, 'PART 1 ', 7)
      CALL STRPUT(T$, 'PART 2 ', 7)
      CALL STRCAT(S$, T$)
      CALL STRPRI(1, S$)
C
C STRING COMPARE TEST
C
      WRITE (1, 303)
  303 FORMAT (1X, 'STRING COMPARE')
      CALL STRPUT(S$, 'A', 1)
      CALL STRPUT(T$, 'A', 1)
      J = STRCMP(S$, T$)
      WRITE (1,304) J
  304 FORMAT (1X, 'A/A ', I6)
      CALL STRPUT(T$, 'B', 1)
      J = STRCMP(S$, T$)
      WRITE (1, 305) J
  305 FORMAT (1X, 'A/B ', I6)
      CALL STRPUT(S$, 'B', 1)
      CALL STRPUT(T$, 'A', 1)
      J = STRCMP(S$, T$)
      WRITE (1, 306) J
  306 FORMAT (1X, 'B/A ', I6)
C
C STRPRI EMPTY STRING
C
      CALL STRPRI(1, EMPTY$)
C
C INSTR TEST
C
      CALL STRPUT(S$, 'XYZ', 3)
      CALL STRPUT(T$, 'XYZZYXYZXYZ', 11)
      J = INSTR(1, T$, S$)
      I = 1
      WRITE (1, 307) J, I
  307 FORMAT (1X, 'INSTR ', I6, ' SHOULD BE ', I6)
      CALL STRPUT(S$, 'ABC', 3)
      J = INSTR(1, T$, S$)
      I = 0
      WRITE (1, 307) J, I
      CALL STRPUT(S$, 'XYZX', 4)
      J = INSTR(1, T$, S$)
      I = 6
      WRITE (1, 307) J, I
      CALL STRPUT(S$, 'YZXYZ', 5)
      J = INSTR(2, T$, S$)
      I = 7
      WRITE (1, 307) J, I
C
C TEST STR$ BUILDER, CMDLN$ COMMAND LINE ACCESS
C NOTE THAT STRPRI, STR$ AND CMDLN$ ALL USE STRBUF,
C THE 132 BYTE BUFFER IN STRCON. STRBUF IS ONLY A
C VERY TEMPORARY BUFFER FOR STRING FUNCTIONS.
C
      M = MARK(0)
      CALL STRPRI(1, STR$('/HELLO, WORLD/'))
      I = STRLEN(CMDLN$(0))
      WRITE (1, 308) I
  308 FORMAT (1X, 'CMDLN LENGTH ', I6)
      CALL STRPRI(1, CMDLN$(0))
C
C ENCODE
C
C NO RANGE CHECK. NO RETURN OF NUMBER OF CHARACTERS. TO MAKE THIS
C USABLE. SUBROUTINE BLANK IS PROVIDED AND TRIM$. BUFFER STRBUF
C IS AVAILABLE (132 BYTES).
C
      CALL BLANK(STRBUF, 132)
      ENCODE (STRBUF, 309) I
  309 FORMAT ('ENCODE ', I6)
      U$ = TEMP$(132)
      CALL STRPUT(U$, STRBUF, 132)
      CALL STRPRI(1, TRIM$(U$, 2))
      CALL RELEAS(M)
C
      M = MARK(0)
C
C RULES FOR HOLLERITH ASSIGN ARE NOT CLEAR. THIS IS NOT A FEATURE
C OF FORTRAN 66, BUT IT DOES WORK IN F80. IN MOST CASES STR$ WOULD
C BE EASIER, BUT HERE WE WANT TO INCLUDE CONTROL CHARACTERS. NOTE
C THAT THIS ARGUES FOR AN EXTENSIONTO STR$ TO SUPPORT ^ SYNTAX
C LIKE SUBMIT, OR PMATE (WHERE ^^ IS A SINGLE ^). WE HAVE IMPLEMENTED
C THAT SYNTAX AS BELOW.
C
C     U$ = TEMP$(3)
C     STRBUF(1) = 13
C     STRBUF(2) = 10
C     STRBUF(3) = '*'
C     CALL STRPUT(U$, STRBUF, 3)
      V$ = INPUT$(STR$('/^M^J*/'))
      CALL STRPRI(1, STR$('/THE STRING INPUT WAS:/'))
      CALL STRPRI(1, V$)
      CALL RELEAS(M)
C
C USE VARPTR
C
      B = 55
      JJ = VARPTR(B) - VARPTR(STRDAT(1)) + 1
      WRITE (1, 400) JJ, B, STRDAT(JJ)
  400 FORMAT (1X, 'B = ', I6, ' ', I6, ' ', I6)
      V$ = STR$('/ABCD/')
      CALL STRPRI(1, V$)
      I2 = STROFF(V$)
      I3 = STRLEN(V$)
      WRITE (1, 403) I2, I3
  403 FORMAT (1X, 'V$ = ', I6, ' ', I6)
      V$ = MKSTR$(STROFF(V$), STRLEN(V$))
      I4 = STROFF(V$)
      I5 = STRLEN(V$)
      WRITE (1, 403) I4, I5
      JJ = VARPTR(IXX) - VARPTR(STRDAT(1)) + 1
      V$ = MKSTR$(JJ, 4)
      WRITE (1, 402) (IXX(I), I = 1, 4), JJ
  402 FORMAT (1X, 'IXX = ', 4A1, ' ', I6)
      CALL STRPRI(1, V$)
      ASSIGN 501 TO I
      CALL S(I)
  501 WRITE (1, 401)
  401 FORMAT (1X, 'BACK TO MAIN')
C
      S$ = NEW$(80)
      CALL STRCPY(S$, STR$('/12345678/'))
      T$ = MID$(S$, 3, 3)
      IF (STRCMP(T$, STR$('/345/')) .NE. 0) WRITE (1, 404)
  404 FORMAT (1X, 'MID$ FAILED')
      T$ = MID$(S$, 7, 3)
      IF (STRCMP(T$, STR$('/78/')) .NE. 0) WRITE (1, 404)
C
C FORCE SSPACE ERROR, BY ATTEMPTING TO CREATE A STRING THAT
C IS JUST TOO BIG.
C
      U$ = NEW$(5000)
      END
C
C PARAMETER I WILL BE THE ADDRESS OF LABEL 501 IN THE MAIN PROGRAM.
C AS THIS IS ALSO THE RETURN ADDRESS, WE CAN TEST THAT.
C
C 'J = $POP(0)  GOTO J' IS THEN EQUIVALENT TO 'RETURN'
C
      SUBROUTINE S(I)
      INTEGER I
C
      INTEGER J
C
      INCLUDE STRING.INC
C
      J = $POP(0)
      IF (I .EQ. J) WRITE (1,300)
  300 FORMAT (1X,'501 IS RETURN')
      IF (I .NE. J) WRITE (1,301)
  301 FORMAT (1X,'501 IS NOT RETURN')
      GO TO I
      END

