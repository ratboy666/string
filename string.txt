STRING.TXT


Introduction ==================================================================


STRLIB.REL is a string handling library for Microsoft FORTRAN-80.
My initial target for AM9511 support was F80, but F80 implements
FORTRAN IV, which is quite poor with string handling. MBASIC is
better, but the garbage collection can take a long time on a 2MHz
8080.

David R Hanson published "A Simple Technique for Representing Strings
in FORTRAN IV" in Communications of the ACM, November 1974. STRLIB
is an implementation of that technique.

The basic technique is to define a string by an offset and a length.
These are two integers, and are packed into a single REAL number.
FORTRAN-80 EQUIVALENCE statement is used to cast the REAL into the
two needed INTEGER values.

We merge the Hanson technique, with a mark/release storage strategy
from UCSD Pascal to provide a useful, performance oriented string
library for Microsoft FORTRAN-80 (F80) on even the 2Mhz 8080. We
also document some of the BDOS level console, punch and reader
calls available in the FORTRAN-80 library (FORLIB.REL).

The STRLEN() function returns the length field STROFF() returns the
offset from the REAL. MKSTR() returns a REAL given integer offset
and length. These calls can be avoided by using the EQUIVALENCE
statement, but are available.

String storage is an arrray STRDAT (string data). All offsets are in
the same array. This string space is divided into three sections: a
PERMANENT area, a TEMPORARY area and FREE area. The permanent area is
at index 1 and up, while the temporary area grows down from the top.
The free area is between the permanent and temporary areas. A mark and
release strategy is used to manage the temporary area, avoiding the
costly garbage collection of MBASIC. As a pleasant benefit, LEFT$,
RIGHT$ and MID$ return descriptors pointing to the source string;
we ensure that middle of string cannot be assigned ("mostly" invariant).
The only string modification is string concatenate (STRCAT). But, the
RIGHT$, LEFT$ and MID$ functions work very quickly, as they need only
create a new descriptor, with no data being copied. Since substring
functions do not use additional string storage, less storage in
the STRDAT is needed. Functions that consume new STRDAT storage are
NEW$, TEMP$, STR$, CMDLN$ and INPUT$. NEW$ is the only function that
returns PERMANENT space -- the other functions return TEMPORARY space.

The offset of a string is an index into STRDAT. This is usually in
STRDAT storage units. The length of a string is always in characters.
The functions in STRLIB should be optimized for the machine they are
on. The FORTRAN-80 implementation uses BYTE as the STRDAT type. But, the
range of a BYTE is -128..127. For compares, etc. 128 is added to the
character value if it is negative. This brings the range to 0..255.
Note that this drives the choice of 257 for "no character".


Use and Linking ===============================================================


STRING.FOR is an example of the use of STRLIB:

  F80 =STRING
  L80 STRING,STRSTO,STRLIB/S,FORLIB/S,STRING/N/Y/E

will compile and link STRING.FOR. STRSTO.REL contains the definition
of the dynamic string storage area. STRSTO.FOR defines it as 4096
bytes (default). More or less storage can be use by editing STRSTO.FOR,
compiling it and linking the new STRSTO.REL. STRSTO.REL must be linked
before STRLIB.REL is searched. Note that we have to be explicit about
FORLIB, because bringing in STRLIB somehow overrides L80 automatic
request. (I consider this a bug in L80).

The STRGET and STRPUT routines, with the STRLEN() function, allow the
use of STRLIB with other string handling routines. The string data
can be transferred into BYTE (or other type) buffers, which can be
controlled by other software. The STRSTO common storage can be adjusted
in size, and used as generic storage with STRGET and STRPUT. STRLEN
again is used to determine the amount of data used in the STRDAT array.
This provides a mechanism similar to dynamic storage, but uses a
MARK/RELEAS stack discipline. The advantage to MARK/RELEAS is that
this is a very fast method for allocating and returning storage.
It does require more care than a malloc()/free() approach, but with
only 64K of available memory and a 2Mhz processor, this is not a
bad thing.

Microsoft FORTRAN-80 supports ENCODE and DECODE. ENCODE is a WRITE
to a memory buffer, and DECODE is READ. We want to be able to
exploit these statements in our programs. However, the buffer is
not filled with spaces, and the number of characters output is not
returned. The exact number of characters in the buffer can be determined
from the FORMAT, but BLANKing the buffer first is easier and allows us
to edit FORMAT statements without as much care needed. We also provide a 
TRIM$ function to remove leading and trailing blanks from a string.

The STR$ function may be used if we want to work with a string constant
in an expression. For example:

  I = STRCMP(S$, STR$('/VAL/'))

will set I to 0 if S$ has value VAL. The string returned by STR$ is
in temporary space, MARK and RELEAS are used to reclaim the storage
used. To avoid having the count the number of characters in the string
constant, the first character is a delimeter. The characters until
the closing delimiter are used as the string value. STR$ may also be
used with STRCPY to assign a string; STRCAT to append a constant string.

The MKSTR$ function returns a string given a desired offset and length.
MKSTR$(STROFF(S$),STRLEN(S$)) returns S$. If STRLEN(S$) is .GT. 0:
FIRST$ = MKSTR(STROFF(S$),1) returns a string containing the first
character, and REST$ = MKSTR(STROFF(S$)+1,STRLEN(S$)-1) returns the
remainder of the string.


Routines ======================================================================


      EXTERNAL STRSTO,STROFF,STRLEN,NEW$,TEMP$,MARK,RELEAS,STRCMP
      EXTERNAL STRPUT,STRGET,STRCPY,STRPRI,LEFT$,MID$,RIGHT$,INSTR
      EXTERNAL STR$,CMDLN$,BLANK,TRIM$,MKSTR$,CHARAT,STRCAT,INPUT$
      EXTERNAL CONOUT,CONRBF,READER,PUNCH,INKEY

      INTEGER STROFF,STRLEN,MARK,STRCMP,INSTR,CHARAT,READER,INKEY
      REAL NEW$,TEMP$,LEFT$,MID$,RIGHT$,STR$,CMDLN$,TRIM$,MKSTR$
      REAL INPUT$

CONOUT, READER, PUNCH and INKEY are part of FORLIB.REL. They are
documented here. The FORTRAN-80 manual doesn't mention these
functions, but they are provided in TTYDRV.MAC.


Detail ========================================================================


COMMON STRSTO - STRING STORAGE
    INTEGER STRMAX           Last used temporary index
    INTEGER STRUSE           First free string data index
    BYTE STRDAT(4096)        String data

COMMON STRCON - STRING CONSTANTS, etc.
    REAL EMPTY$              Empty string (length 0)
    INTEGER NOCHAR           "No character" see CHARAT
    BYTE STRBUF(132)         Working buffer for STRLIB routines

FUNCTION STROFF(S$)          Returns offset (1 based) of string in STRDAT
    INTEGER STROFF
    REAL S$

FUNCTION STRLEN(S$)          Return length of string S$
    INTEGER STRLEN
    REAL S$

SUBROUTINE STRPUT(S$,D,N)    Puts bytes into string
    REAL S$                  Put N bytes from byte array D into string S$.
    INTEGER N                String S$ must be large enough to accmodate N
    BYTE D(N)                bytes of data (See NEW$ and TEMP$).

SUBROUTINE STRGET(S$,D,N)    Get bytes from strings. Get N bytes from string
    REAL S$                  S$ to array D. Takes the smaller of N or
    INTEGER N                STRLEN(S$). This is used to access the actual
    BYTE D(N)                characters in the string (See CHARAT).

FUNCTION CHARAT(S$,I)        Character At. Gets a single character from string.
    INTEGER CHARAT           S$. Returns NOCHAR if index I is not in the
    REAL S$                  string. Returns -128..128, or 257 
    INTEGER I             

FUNCTION MARK(DUMMY)         Return storage mark for RELEAS. DUMMY is not used.
    INTEGER MARK             MARK works withh RELEAS. It returns a 'mark' in
    INTEGER DUMMY            string storage. Temporary strings can then be
                             allocated with function TEMP$. When the temporary
                             strings are to be released, the RELEAS subroutine
                             is used to release all temorary storage back to
                             to the MARK. The string routines do not implement
                             dynamic storage, but the mark/release strategy
                             works very well, and provides performance.

SUBROUTINE RELEAS(M)         Release all temporary storage to mark M. Release
    INTEGER M                all temporaries allocation with TEMP$ to last
                             mark. See MARK function for more details.

FUNCTION TEMP$(N)            Allocate temporary string of size N. Allocates
    REAL TEMP$               a temporary string of size N. The string is set
    INTEGER N                to length 0. See MARK and RELEAS for details on
                             storage management.

FUNCTION NEW$(N)             Allocate permanent string of size N. NEW$
    REAL NEW$                allocates a new string of size N. Unlike strings
    INTEGER N                allocated with TEMP$, storage cannot be reclaimed.
                             NEW$ and TEMP$ strings share the same storage
                             array. The string returned is of length 0.

SUBROUTINE STRCPY(DST$,SRC$) Copy SRC$ to DST$. DST$ must be large enough
    REAL DST$,SRC$           to accomodate SRC$.

SUBROUTINE STRCAT(DST$,SRC$) Concatenate SRC$ to the end of DST$. DST$ must be
    REAL DST$,SRC$           long enough to accomodate the result as this is
                             not range checked.

SUBROUTINE STRPRI(S$)        Print S$ for a maximum of 132 character. It is
    REAL S$                  printed on a line by itself. Uses STRGET and
                             STRLEN functions. You may just want to use
                             STRPRI as an example.

FUNCTION LEFT$(S$,N)         Return leftmost N characters of string S$.
    REAL LEFT$               From MBASIC.
    REAL S$
    INTEGER N

FUNCTION MID$(S$,N,M)        Return M characters beginning with offset N
    REAL MID$                of string S$. From MBASIC.
    REAL S$
    INTEGER N,M

FUNCTION RIGHT$(S$,N)        Return rightmost N characters of string S$.
    REAL RIGHT$              From MBASIC.
    REAL S$
    INTEGER N

FUNCTION STRCMP(S1$,S2$)     String compare. Compare strings S1$ and S2$.
    INTEGER STRCMP           Return positive if S1$ is larger, zero if equal,
    REAL S1$,S2$             and negative if S2$ is larger. Compare by
                             comparing each character. Views each character as
                             value 0..255. Since ASCII is used, 65 is uppercase
                             A, 97 is is lowercase a. ASCII only defines
                             characters 0 to 127. The range 128 to 255 is not
                             defined. If the character set is UTF-8, all values
                             are significant (also for binary data).

FUNCTION INSTR(I,X$,Y$)      Searches for first occurrentce of Y$ in X$ and
    INTEGER INSTR            returns position. I is the position to begin the
    INTEGER I                search. Returns 0 on not found, or position.
    REAL X$,Y$

FUNCTION STR$('/STRING/')    Create a string from S$, which is delimited. The
    REAL STR$                first character is the delimiter, and must be the
                             last as well. The string is in temporary space.

FUNCTION CMDLN$(DUMMY)       Gets command line as a string. DUMMY is not used.
    REAL CMDLN$              Get the command line before doing disk I/O
    INTEGER DUMMY            which may destroy the command buffer at 0080H.
                             String returned is a temporary string.

SUBROUTINE BLANK(BUF,N)      Blanks buffer BUF for N characters.
    BYTE BUF(N)
    INTEGER N

FUNCTION TRIM$(S$,N)         Trim leading and trailing spaces from S$. N is
    REAL TRIM$               1 for left, 2 for right and 3 for both.
    INTEGER N

FUNCTION MKSTR$(OFF,LEN)     Return string using offset OFF and length LEN.
    REAL MKSTR$              This seriously leaks the implementation as does
    INTEGER OFF,LEN          STROFF

FUNCTION INPUT$(P$)          Input a line with prompt P$. XSUB compatible.
    REAL INPUT$              Returns string in temporary space.
    REAL P$                  Uses CONOUT and CONRBF

SUBROUTINE CONOUT(C)         Access BDOS function 2 (Console Out)
    BYTE C

SUBROUTINE CONRBF(BUF)       Access BDOS function 10 (Console Read Buffer)
    BYTE BUF(1)

SUBROUTINE PUNCH(C)          Send character to PTP
    BYTE C                   Access BDOS function 4

FUNCTION READER(DUMMY)       Read character from PTR
    BYTE READER              Access BDOS function 3
    INTEGER DUMMY

FUNCTION INKEY(I)            Get from keyboard. I=0, status (0=no char)
    BYTE INKEY               I=1, wait (return char)
    INTEGER I                Access BDOS function 6, E=0FFH
               